/*
 * Copyright (C) 2016-2025 The MegaMek Team. All Rights Reserved.
 *
 * This file is part of MekHQ.
 *
 * MekHQ is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License (GPL),
 * version 3 or (at your option) any later version,
 * as published by the Free Software Foundation.
 *
 * MekHQ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * A copy of the GPL should have been included with this project;
 * if not, see <https://www.gnu.org/licenses/>.
 *
 * NOTICE: The MegaMek organization is a non-profit group of volunteers
 * creating free software for the BattleTech community.
 *
 * MechWarrior, BattleMech, `Mech and AeroTech are registered trademarks
 * of The Topps Company, Inc. All Rights Reserved.
 *
 * Catalyst Game Labs and the Catalyst Game Labs logo are trademarks of
 * InMediaRes Productions, LLC.
 *
 * MechWarrior Copyright Microsoft Corporation. MekHQ was created under
 * Microsoft's "Game Content Usage Rules"
 * <https://www.xbox.com/en-US/developers/rules> and it is not endorsed by or
 * affiliated with Microsoft.
 */
package mekhq.gui.model;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.ResourceBundle;
import java.util.Set;
import javax.swing.AbstractCellEditor;
import javax.swing.Action;
import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.UIManager;
import javax.swing.border.Border;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;

import mekhq.MekHQ;
import mekhq.campaign.parts.Part;
import mekhq.campaign.parts.PartInUse;
import mekhq.gui.utilities.MekHqTableCellRenderer;

public class PartsInUseTableModel extends DataTableModel<PartInUse> {
    private static final DecimalFormat FORMATTER = new DecimalFormat();

    static {
        FORMATTER.setMaximumFractionDigits(3);
    }

    private static final String EMPTY_CELL = "";

    public static final int COL_PART = 0;
    public static final int COL_TECH_BASE = 1;
    public static final int COL_IN_USE = 2;
    public static final int COL_STORED = 3;
    public static final int COL_TONNAGE = 4;
    public static final int COL_REQUESTED_STOCK = 5;
    public static final int COL_IN_TRANSFER = 6;
    public static final int COL_COST = 7;
    public static final int COL_BUTTON_BUY = 8;
    public static final int COL_BUTTON_BUY_BULK = 9;
    public static final int COL_BUTTON_SELL = 10;
    public static final int COL_BUTTON_SELL_BULK = 11;
    public static final int COL_BUTTON_GM_ADD = 12;
    public static final int COL_BUTTON_GM_ADD_BULK = 13;

    private final transient ResourceBundle resourceMap = ResourceBundle.getBundle("mekhq.resources.PartsInUseTableModel",
          MekHQ.getMHQOptions().getLocale());

    public PartsInUseTableModel() {
        data = new ArrayList<>();
    }

    @Override
    public int getColumnCount() {
        return COL_BUTTON_GM_ADD_BULK + 1;
    }

    @Override
    public String getColumnName(int column) {
        return switch (column) {
            case COL_PART -> resourceMap.getString("part.heading");
            case COL_TECH_BASE -> resourceMap.getString("techBase.heading");
            case COL_IN_USE -> resourceMap.getString("inUse.heading");
            case COL_STORED -> resourceMap.getString("stored.heading");
            case COL_TONNAGE -> resourceMap.getString("storedTonnage.heading");
            case COL_IN_TRANSFER -> resourceMap.getString("ordered.heading");
            case COL_COST -> resourceMap.getString("cost.heading");
            case COL_REQUESTED_STOCK -> resourceMap.getString("requestedStock.heading");
            default -> EMPTY_CELL;
        };
    }

    @Override
    public Object getValueAt(int row, int column) {
        PartInUse partInUse = getPartInUse(row);
        switch (column) {
            case COL_PART:
                return partInUse.getDescription();
            case COL_TECH_BASE:
                return Part.getTechBaseName(partInUse.getTechBase());
            case COL_IN_USE:
                return FORMATTER.format(partInUse.getUseCount());
            case COL_STORED:
                return (partInUse.getStoreCount() > 0) ? FORMATTER.format(partInUse.getStoreCount()) : EMPTY_CELL;
            case COL_TONNAGE:
                return (partInUse.getStoreTonnage() > 0) ? FORMATTER.format(partInUse.getStoreTonnage()) : EMPTY_CELL;
            case COL_IN_TRANSFER:
                if (partInUse.getTransferCount() > 0 && partInUse.getPlannedCount() <= 0) {
                    return FORMATTER.format(partInUse.getTransferCount());
                } else if (partInUse.getPlannedCount() > 0) {
                    return String.format("%s [+%s]",
                          FORMATTER.format(partInUse.getTransferCount()),
                          FORMATTER.format(partInUse.getPlannedCount()));
                } else {
                    return EMPTY_CELL;
                }
            case COL_COST:
                return partInUse.getCost().toAmountAndSymbolString();
            case COL_BUTTON_BUY:
                return resourceMap.getString("buy.text");
            case COL_BUTTON_BUY_BULK:
                return resourceMap.getString("buyInBulk.text");
            case COL_BUTTON_SELL:
                return resourceMap.getString("sell.text");
            case COL_BUTTON_SELL_BULK:
                return resourceMap.getString("sellInBulk.text");
            case COL_BUTTON_GM_ADD:
                return resourceMap.getString("add.text");
            case COL_BUTTON_GM_ADD_BULK:
                return resourceMap.getString("addInBulk.text");
            case COL_REQUESTED_STOCK:
                return partInUse.getRequestedStock() + "%";
            default:
                return EMPTY_CELL;
        }
    }

    @Override
    public Class<?> getColumnClass(int c) {
        return String.class;
    }

    @Override
    public boolean isCellEditable(int row, int col) {
        return switch (col) {
            case COL_BUTTON_BUY,
                 COL_BUTTON_BUY_BULK,
                 COL_BUTTON_SELL,
                 COL_BUTTON_SELL_BULK,
                 COL_BUTTON_GM_ADD,
                 COL_BUTTON_GM_ADD_BULK,
                 COL_REQUESTED_STOCK -> true;
            default -> false;
        };
    }

    public void setData(Set<PartInUse> data) {
        setData(new ArrayList<>(data));
    }

    public void updateRow(int row, PartInUse partInUse) {
        data.set(row, partInUse);
        fireTableRowsUpdated(row, row);
    }

    public PartInUse getPartInUse(int row) {
        if ((row < 0) || (row >= data.size())) {
            return null;
        }
        return data.get(row);
    }

    public boolean isBuyable(int row) {
        return (row >= 0) && (row < data.size())
                     && (null != data.get(row).getPartToBuy());
    }

    public int getAlignment(int column) {
        return switch (column) {
            case COL_PART, COL_TECH_BASE -> SwingConstants.LEFT;
            case COL_IN_USE, COL_STORED, COL_TONNAGE, COL_IN_TRANSFER, COL_COST, COL_REQUESTED_STOCK ->
                  SwingConstants.RIGHT;
            default -> SwingConstants.CENTER;
        };
    }

    public int getPreferredWidth(int column) {
        return switch (column) {
            case COL_PART -> 260;
            case COL_TECH_BASE, COL_IN_USE, COL_STORED, COL_TONNAGE, COL_IN_TRANSFER -> 15;
            case COL_COST -> 40;
            case COL_BUTTON_BUY, COL_BUTTON_SELL -> 25;
            case COL_BUTTON_GM_ADD, COL_BUTTON_BUY_BULK, COL_BUTTON_SELL_BULK -> 65;
            case COL_REQUESTED_STOCK -> 45;
            default -> 100;
        };
    }

    public boolean hasConstantWidth(int col) {
        return switch (col) {
            case COL_BUTTON_BUY,
                 COL_BUTTON_BUY_BULK,
                 COL_BUTTON_SELL,
                 COL_BUTTON_SELL_BULK,
                 COL_BUTTON_GM_ADD,
                 COL_BUTTON_GM_ADD_BULK -> true;
            default -> false;
        };
    }

    public int getWidth(int col) {
        return switch (col) {
            case COL_BUTTON_BUY,
                 COL_BUTTON_BUY_BULK,
                 COL_BUTTON_SELL,
                 COL_BUTTON_SELL_BULK,
                 COL_BUTTON_GM_ADD,
                 COL_BUTTON_GM_ADD_BULK -> {
                // Calculate from button width, respecting style
                JButton btn = new JButton(getValueAt(0, col).toString());
                yield btn.getPreferredSize().width;
            }
            default -> Integer.MAX_VALUE;
        };
    }

    public PartsInUseTableModel.Renderer getRenderer() {
        return new PartsInUseTableModel.Renderer();
    }

    public static class Renderer extends MekHqTableCellRenderer {
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
              boolean isSelected, boolean hasFocus, int row, int column) {
            super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            setOpaque(true);
            setHorizontalAlignment(((PartsInUseTableModel) table.getModel()).getAlignment(column));
            return this;
        }
    }

    public static class ButtonColumn extends AbstractCellEditor
          implements TableCellRenderer, TableCellEditor, ActionListener, MouseListener {

        private final JTable table;
        private final Action action;
        private final Border originalBorder;
        private Border focusBorder;

        private final JButton renderButton;
        private final JButton editButton;
        private Object editorValue;
        private boolean isButtonColumnEditor;
        private boolean enabled;

        public ButtonColumn(JTable table, Action action, int column) {
            this.table = table;
            this.action = action;

            renderButton = new JButton();
            editButton = new JButton();
            editButton.setFocusPainted(false);
            editButton.addActionListener(this);
            originalBorder = editButton.getBorder();
            enabled = true;

            TableColumnModel columnModel = table.getColumnModel();
            columnModel.getColumn(column).setCellRenderer(this);
            columnModel.getColumn(column).setCellEditor(this);
            table.addMouseListener(this);
        }

        public Border getFocusBorder() {
            return focusBorder;
        }

        public void setFocusBorder(Border focusBorder) {
            this.focusBorder = focusBorder;
            editButton.setBorder(focusBorder);
        }

        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
            editButton.setEnabled(enabled);
            renderButton.setEnabled(enabled);
        }

        @Override
        public Object getCellEditorValue() {
            return editorValue;
        }

        @Override
        public void mousePressed(MouseEvent e) {
            if (table.isEditing() && (this == table.getCellEditor())) {
                isButtonColumnEditor = true;
            }
        }

        @Override
        public void mouseReleased(MouseEvent e) {
            if (isButtonColumnEditor && table.isEditing()) {
                table.getCellEditor().stopCellEditing();
            }
            isButtonColumnEditor = false;
        }

        @Override
        public void mouseClicked(MouseEvent e) {
        }

        @Override
        public void mouseEntered(MouseEvent e) {
        }

        @Override
        public void mouseExited(MouseEvent e) {
        }

        @Override
        public void actionPerformed(ActionEvent e) {
            int row = table.convertRowIndexToModel(table.getEditingRow());
            fireEditingStopped();

            // Invoke the Action
            ActionEvent event = new ActionEvent(table, ActionEvent.ACTION_PERFORMED, "" + row);
            action.actionPerformed(event);
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row,
              int column) {
            boolean buyable = ((PartsInUseTableModel) table.getModel())
                                    .isBuyable(table.getRowSorter().convertRowIndexToModel(row));

            if (value == null) {
                editButton.setText(EMPTY_CELL);
                editButton.setIcon(null);
            } else if (value instanceof Icon) {
                editButton.setText(EMPTY_CELL);
                editButton.setIcon((Icon) value);
            } else {
                editButton.setText(value.toString());
                editButton.setIcon(null);
            }
            editButton.setEnabled(enabled && buyable);

            this.editorValue = value;
            return editButton;
        }

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus,
              int row, int column) {
            boolean buyable = ((PartsInUseTableModel) table.getModel())
                                    .isBuyable(table.getRowSorter().convertRowIndexToModel(row));

            if (isSelected && enabled && buyable) {
                renderButton.setForeground(table.getSelectionForeground());
                renderButton.setBackground(table.getSelectionBackground());
            } else {
                renderButton.setForeground(table.getForeground());
                renderButton.setBackground(UIManager.getColor("Button.background"));
            }

            if (hasFocus && enabled && buyable) {
                renderButton.setBorder(focusBorder);
            } else {
                renderButton.setBorder(originalBorder);
            }

            if (value == null) {
                renderButton.setText(EMPTY_CELL);
                renderButton.setIcon(null);
            } else if (value instanceof Icon) {
                renderButton.setText(EMPTY_CELL);
                renderButton.setIcon((Icon) value);
            } else {
                renderButton.setText(value.toString());
                renderButton.setIcon(null);
            }
            renderButton.setEnabled(enabled && buyable);

            return renderButton;
        }
    }

    @Override
    public void setValueAt(Object value, int rowIndex, int columnIndex) {
        if (columnIndex == COL_REQUESTED_STOCK) {
            try {
                //Quick String parsing here, we ignore anything that isn't a number or a . so that a user can input a % symbol or not, it's added regardless
                double newVal = Double.parseDouble(value.toString().replaceAll("[^0-9.]", ""));
                PartInUse partInUse = getPartInUse(rowIndex);
                if (partInUse != null) {
                    partInUse.setRequestedStock(newVal);
                    fireTableCellUpdated(rowIndex, columnIndex);
                }
            } catch (NumberFormatException ignored) {

            }
        } else {
            super.setValueAt(value, rowIndex, columnIndex);
        }
    }
}
